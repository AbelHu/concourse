---

templates:
  - &setup-tugboat
    task: setup-tugboat
    params: &setup-tugboat-params
      ACCESS_TOKEN: {{digitalocean-access-token}}

      SSH_USER: {{digitalocean-ssh-user}}
      SSH_KEY: {{digitalocean-ssh-key}}

      REGION: sfo1
      IMAGE: ""
      SIZE: 1gb
      PRIVATE_NETWORKING: 'false'
      BACKUPS_ENABLED: 'false'
      IP6: 'false'
      OS: ""
      USER_NAME: 'root'

    config:
      platform: linux

      image_resource:
        type: docker-image
        source:
          repository: ruby
          tag: '2.1'

      outputs:
      - name: keys
      - name: config

      run:
        path: bash
        args:
        - -c
        - |
          set -e

          echo "writing ssh key"
          cat <<EOF > keys/id_rsa
          $SSH_KEY
          EOF

          echo "chmodding ssh key"
          chmod 0600 keys/id_rsa

          echo "creating pub key"
          ssh-keygen -y -f keys/id_rsa > keys/id_rsa.pub

          fingerprint=$(ssh-keygen -lf keys/id_rsa.pub | cut -d' ' -f2)

          echo "writing .tugboat"
          cat << EOF > config/.tugboat
          ---
          authentication:
            access_token: $ACCESS_TOKEN
          ssh:
            ssh_user: $SSH_USER
            ssh_key_path: keys/id_rsa
            ssh_port: '22'
          defaults:
            region: $REGION
            image: $IMAGE
            size: $SIZE
            ssh_key: ["$fingerprint"]
            private_networking: $PRIVATE_NETWORKING
            backups_enabled: $BACKUPS_ENABLED
            ip6: $IP6
          EOF

  - &create-droplet
    task: create-droplet
    params: &create-droplet-params
      OS: ""
      USER_NAME: ""

    config:
      platform: linux

      image_resource:
        type: docker-image
        source:
          repository: ruby
          tag: '2.1'

      inputs:
      - name: config
      - name: keys

      outputs:
      - name: instance

      run:
        path: bash
        args:
        - -c
        - |
          set -ex

          cp config/.tugboat .

          gem install tugboat

          tugboat create smoke-test-$OS
          trap "tugboat destroy --confirm smoke-test-$OS" ERR TERM INT

          tugboat wait smoke-test-$OS

          tugboat info smoke-test-$OS | grep IP | awk '{print $NF}' > instance/ip

          ip=$(cat instance/ip)

          until ssh -q -i keys/id_rsa -o StrictHostKeyChecking=no $USER_NAME@${ip} "exit 0"; do
            echo "waiting for ssh to become available..."
            sleep 1
          done

  - &teardown-droplet
    task: teardown
    params: &teardown-droplet-params
      OS: ""

    config:
      platform: linux

      image_resource:
        type: docker-image
        source:
          repository: ruby
          tag: '2.1'

      inputs:
      - name: config

      run:
        path: bash
        args:
        - -c
        - |
          gem install tugboat

          cp config/.tugboat .

          tugboat destroy --confirm smoke-test-$OS

  - &launch-ec2-instance
    task: launch-ec2-instance
    params: &launch-ec2-instance-params
      AWS_ACCESS_KEY_ID: {{binary-test-aws-access-key}}
      AWS_SECRET_ACCESS_KEY: {{binary-test-aws-secret-key}}
      IMAGE_ID: ""
      USER_NAME: ""

    config:
      platform: linux

      image_resource:
        type: docker-image
        source:
          repository: concourse/binary-test-ec2

      outputs:
      - name: instance
      - name: keys

      run:
        path: bash
        args:
        - -c
        - |
          set -e -x

          mkdir -p ~/.aws

          cat << EOF > ~/.aws/config
          [default]
          output = json
          region = us-east-1
          EOF

          VPC_CIDR_BLOCK="10.0.0.0/16"
          SUBNET_CIDR_BLOCK="10.0.0.0/24"

          #only works on Linux (use uuidgen otherwise)
          KEY_NAME="bin-test-$(date +%s)"
          aws ec2 wait image-exists --image-ids $IMAGE_ID

          set +x
          aws ec2 create-key-pair --key-name $KEY_NAME | jq ".KeyMaterial" | tr -d '"' > escaped_key
          # we're going to call this PEM formatted key `id_rsa` so we get some task reuse while still being lazy
          echo -e $(cat escaped_key) > keys/id_rsa
          rm -f escaped_key
          chmod 0400 keys/id_rsa
          set -x

          VPC_ID=$(aws ec2 create-vpc --cidr-block $VPC_CIDR_BLOCK | jq ".Vpc.VpcId" | tr -d '"')

          trap "aws ec2 delete-vpc --vpc-id $VPC_ID" ERR TERM INT

          aws ec2 wait vpc-available --vpc-ids $VPC_ID

          SUBNET_ID=$(aws ec2 create-subnet --vpc-id $VPC_ID --cidr-block $SUBNET_CIDR_BLOCK | jq ".Subnet.SubnetId" | tr -d '"')
          aws ec2 wait subnet-available --subnet-ids $SUBNET_ID

          ip_info=$(aws ec2 allocate-address)
          IP=$(echo $ip_info | jq ".PublicIp" | tr -d '"')
          echo $IP > instance/ip

          ALLOCATION_ID=$(echo $ip_info | jq ".AllocationId" | tr -d '"')

          GATEWAY_ID=$(aws ec2 create-internet-gateway | jq ".InternetGateway.InternetGatewayId" | tr -d '"')
          aws ec2 attach-internet-gateway --internet-gateway-id $GATEWAY_ID --vpc-id $VPC_ID

          ROUTE_TABLE_ID=$(aws ec2 describe-route-tables --filters "Name=vpc-id,Values=$VPC_ID" | jq ".RouteTables[0].RouteTableId" | tr -d '"')
          aws ec2 create-route --route-table-id $ROUTE_TABLE_ID --destination-cidr-block 0.0.0.0/0 --gateway-id $GATEWAY_ID

          SECURITY_GROUP_ID=$(aws ec2 create-security-group --group-name "concourse binary test security group" --description "concourse binary test security group" --vpc-id $VPC_ID | jq ".GroupId" | tr -d '"')
          aws ec2 authorize-security-group-ingress --group-id $SECURITY_GROUP_ID --protocol tcp --port 22 --cidr 0.0.0.0/0

          INSTANCE_ID=$(aws ec2 run-instances --image-id $IMAGE_ID --key-name $KEY_NAME --security-group-ids $SECURITY_GROUP_ID --instance-type m4.large --subnet-id $SUBNET_ID | jq ".Instances[0].InstanceId" | tr -d '"')

          cat << EOF > instance/cleanup
          #!/usr/bin/env bash

          export AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID
          export AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY
          export AWS_DEFAULT_REGION=us-east-1

          set -e -x

          INSTANCE_ID=$INSTANCE_ID
          ALLOCATION_ID=$ALLOCATION_ID
          KEY_NAME=$KEY_NAME
          SECURITY_GROUP_ID=$SECURITY_GROUP_ID
          SUBNET_ID=$SUBNET_ID
          GATEWAY_ID=$GATEWAY_ID
          VPC_ID=$VPC_ID

          function cleanup_account()
          {

            if [ -n "$INSTANCE_ID" ]; then
              until aws ec2 terminate-instances --instance-ids $INSTANCE_ID; do
                echo "terminating instance"
                sleep 1
              done

              aws ec2 wait instance-terminated --instance-ids $INSTANCE_ID
            fi

            until aws ec2 release-address --allocation-id $ALLOCATION_ID; do
              echo "releasing elastic ip"
              sleep 1
            done

            until aws ec2 delete-key-pair --key-name $KEY_NAME; do
              echo "deleting key pair"
              sleep 1
            done

            until aws ec2 delete-security-group --group-id $SECURITY_GROUP_ID; do
              echo "deleting security group"
              sleep 1
            done

            until aws ec2 delete-subnet --subnet-id $SUBNET_ID; do
              echo "deleting subnet"
              sleep 1
            done

            until aws ec2 detach-internet-gateway --internet-gateway-id $GATEWAY_ID --vpc-id $VPC_ID; do
              echo "detaching internet gateway"
              sleep 1
            done

            until aws ec2 delete-internet-gateway --internet-gateway-id $GATEWAY_ID; do
              echo "echo deleting internet gateway"
              sleep 1
            done

            until aws ec2 delete-vpc --vpc-id $VPC_ID; do
              echo "deleting vpc"
              sleep 1
            done
          }

          cleanup_account
          EOF

          chmod +x instance/cleanup

          trap ./instance/cleanup ERR TERM INT

          aws ec2 wait instance-running --instance-ids $INSTANCE_ID
          aws ec2 wait instance-status-ok --instance-ids $INSTANCE_ID

          aws ec2 associate-address --instance-id $INSTANCE_ID --allocation-id $ALLOCATION_ID

          until ssh -q -i keys/id_rsa -o StrictHostKeyChecking=no $USER_NAME@$IP "exit 0"; do
            echo "waiting for ssh to become available..."
            sleep 1
          done

  - &teardown-ec2-instance
    task: teardown
    params: &teardown-droplet-params
      OS: ""

    config:
      platform: linux

      image_resource:
        type: docker-image
        source:
          repository: calebamiles/binary-test-ec2

      inputs:
      - name: instance

      run:
        path: bash
        args:
        - -c
        - |
          ./instance/cleanup

  - &install-postgres-xenial
    task: install-postgres
    params: &install-postgres-xenial-params
      USER_NAME: ""

    config:
      platform: linux

      image_resource:
        type: docker-image
        source:
          repository: ruby
          tag: "2.1"

      inputs:
      - name: keys
      - name: instance

      run:
        path: bash
        args:
        - -c
        - |
          cat <<EOC > install_postgres
          set -ex

          until sudo apt-get update; do
            echo "waiting for apt lock"
            sleep 1
          done

          until sudo apt-get -y install postgresql; do
            echo "waiting for apt lock"
            sleep 1
          done

          sudo -Hiu postgres psql -U postgres postgres <<EOF
            CREATE USER $USER_NAME SUPERUSER PASSWORD '' ;
          EOF

          createdb atc
          EOC

          ip=$(cat instance/ip)

          scp -q -i keys/id_rsa -o StrictHostKeyChecking=no install_postgres $USER_NAME@${ip}:
          ssh -q -i keys/id_rsa -o StrictHostKeyChecking=no $USER_NAME@${ip} "chmod +x install_postgres && ./install_postgres"

  - &install-postgres-fedora
    task: install-postgres
    params: &install-postgres-fedora-params
      OS: ""
      USER_NAME: ""

    config:
      platform: linux

      image_resource:
        type: docker-image
        source:
          repository: ruby
          tag: '2.1'

      inputs:
      - name: keys
      - name: instance

      run:
        path: bash
        args:
        - -c
        - |
          cat <<EOC > install_postgres
          set -ex

          sudo dnf install -y postgresql-server postgresql
          sudo postgresql-setup --initdb --unit postgresql

          echo "local all all peer" | sudo tee /var/lib/pgsql/data/pg_hba.conf
          echo "host all all 127.0.0.1/32 trust" | sudo tee -a /var/lib/pgsql/data/pg_hba.conf

          sudo systemctl start postgresql

          sudo -Hiu postgres psql -U postgres postgres <<EOF
            CREATE USER $USER_NAME SUPERUSER PASSWORD '' ;
          EOF

          createdb atc
          EOC

          ip=$(cat instance/ip)

          scp -q -i keys/id_rsa -o StrictHostKeyChecking=no install_postgres $USER_NAME@${ip}:
          ssh -q -i keys/id_rsa -o StrictHostKeyChecking=no $USER_NAME@${ip} "chmod +x install_postgres && ./install_postgres"

  - &fedora-dependencies
    task: fedora-dependencies
    params: &fedora-dependencies-params
      USER_NAME: ""
    config:
      platform: linux

      image_resource:
        type: docker-image
        source:
          repository: ruby
          tag: '2.1'

      inputs:
      - name: keys
      - name: instance

      run:
        path: bash
        args:
        - -c
        - |
          cat <<EOC > install_deps
          set -ex

          export LANG=en_US.UTF-8
          export LC_ALL=en_US.UTF-8

          echo "sudo %_install_langs all" | sudo tee /etc/rpm/macros.image-language-conf
          sudo dnf reinstall -y glibc-common
          sudo dnf upgrade -y glibc glibc-common

          sudo dnf install -y tcping wget psmisc
          EOC

          ip=$(cat instance/ip)

          scp -q -i keys/id_rsa -o StrictHostKeyChecking=no install_deps $USER_NAME@${ip}:
          ssh -q -i keys/id_rsa -o StrictHostKeyChecking=no $USER_NAME@${ip} "chmod +x install_deps && ./install_deps"

  - &test-binary
    task: test-binary
    params: &test-binary-params
      USER_NAME: ""

    config:
      platform: linux

      image_resource:
        type: docker-image
        source:
          repository: concourse/binary-test-ec2

      inputs:
      - name: bin-rc
      - name: keys
      - name: instance

      run:
        path: bash
        args:
        - -c
        - |
          set -ex

          ip=$(cat instance/ip)

          until scp -q -i keys/id_rsa -o StrictHostKeyChecking=no bin-rc/concourse_linux_amd64 $USER_NAME@${ip}:concourse; do
            echo "waiting for ssh to become available..."
            sleep 1
          done

          ssh -q -i keys/id_rsa -o StrictHostKeyChecking=no $USER_NAME@${ip} "chmod +x concourse"

          cat <<"EOC" > smoke_test
          set -ex

          # ssh
          ssh-keygen -t rsa -f host_key -N ''
          ssh-keygen -t rsa -f worker_key -N ''
          ssh-keygen -t rsa -f session_signing_key -N ''

          cp worker_key.pub authorized_worker_keys

          # bin
          set +x
          echo "starting web"
          ./concourse web \
            --development-mode \
            --session-signing-key session_signing_key \
            --tsa-host-key host_key \
            --tsa-authorized-keys authorized_worker_keys > web.stdout.log 2> web.stderr.log &

          # try to connect to 127.0.0.1:8080 and send nothing
          until [ $(2>/dev/null >/dev/tcp/127.0.0.1/8080 && echo 0 || echo 42) -eq 0 ]; do
            echo "waiting for atc to become available..."
            sleep 1
          done

          wget -q -O fly "http://127.0.0.1:8080/api/v1/cli?arch=amd64&platform=linux"

          echo "starting worker"
          sudo ./concourse worker \
            --work-dir /tmp/worker \
            --tsa-host 127.0.0.1 \
            --tsa-public-key host_key.pub \
            --tsa-worker-private-key worker_key \
            --garden-network-pool 10.255.0.0/22 > worker.stdout.log 2> worker.stderr.log &

          until [ $(curl -s http://127.0.0.1:8080/api/v1/workers | wc -c) -gt 3 ]; do
            echo "waiting for worker to become available..."
            sleep 1
          done

          chmod +x fly
          ./fly -t local login -c http://127.0.0.1:8080

          # task
          cat << EOF > task.yml
          ---
          platform: linux

          image_resource:
            type: docker-image
            source:
              repository: busybox

          run:
            path: sh
            args:
            - -c
            - "echo hi"
          EOF

          # Unprivileged
          ./fly -t local execute -c task.yml

          # Privileged
          ./fly -t local execute -p -c task.yml

          # Cleanup; we won't get here unless executes succeed due to set -e
          killall concourse
          EOC

          echo "copying smoke_test to target"
          scp -q -i keys/id_rsa -o StrictHostKeyChecking=no smoke_test $USER_NAME@${ip}:

          echo "invoking smoke_test"
          ssh -q -i keys/id_rsa -o StrictHostKeyChecking=no $USER_NAME@${ip} "chmod +x smoke_test; ./smoke_test"
          ssh -q -i keys/id_rsa -o StrictHostKeyChecking=no $USER_NAME@${ip} "tar cvfz worker-web-logs.tgz *.log"
          scp -q -i keys/id_rsa -o StrictHostKeyChecking=no $USER_NAME@${ip}:worker-web-logs.tgz .

resources:
- name: bin-rc
  type: github-release
  source:
    user: concourse
    repository: bin
    access_token: {{bin-release-token}}

jobs:
  # empty job included for garden team debugging
- name: digitalocean-centos-7

- name: digitalocean-ubuntu-xenial
  serial: true
  plan:
  - get: bin-rc
    params:
      globs:
      - concourse_linux_amd64

  - <<: *setup-tugboat
    params:
      <<: *setup-tugboat-params
      IMAGE: ubuntu-16-04-x64
      OS: ubuntu
      USER_NAME: root


  - <<: *create-droplet
    params:
      <<: *create-droplet-params
      OS: ubuntu
      USER_NAME: root

  - ensure:
      <<: *teardown-droplet
      params:
        <<: *teardown-droplet-params
        OS: ubuntu

    do:

    - <<: *install-postgres-xenial
      params:
        <<: *install-postgres-xenial-params
        USER_NAME: root

    - <<: *test-binary
      params:
        <<: *test-binary-params
        OS: ubuntu
        USER_NAME: root

- name: digitalocean-fedora-23
  serial: true
  plan:
  - get: bin-rc
    params:
      globs:
      - concourse_linux_amd64

  - <<: *setup-tugboat
    params:
      <<: *setup-tugboat-params
      IMAGE: fedora-23-x64
      OS: fedora
      USER_NAME: root

  - <<: *create-droplet
    params:
      <<: *create-droplet-params
      OS: fedora
      USER_NAME: root

  - ensure:
      <<: *teardown-droplet
      params:
        <<: *teardown-droplet-params
        OS: fedora
        USER_NAME: root

    do:
    - <<: *fedora-dependencies
      params:
        <<: *fedora-dependencies-params
        USER_NAME: fedora

    - <<: *install-postgres-fedora
      params:
        <<: *install-postgres-fedora-params
        OS: fedora
        USER_NAME: root

    - <<: *test-binary
      params:
        <<: *test-binary-params
        OS: fedora
        USER_NAME: root

- name: ec2-ubuntu-xenial
  serial: true
  plan:
  - get: bin-rc
    params:
      globs:
      - concourse_linux_amd64

  - <<: *launch-ec2-instance
    params:
      <<: *launch-ec2-instance-params
      USER_NAME: ubuntu
      IMAGE_ID: ami-840910ee

  - ensure:
      <<: *teardown-ec2-instance

    do:

    - <<: *install-postgres-xenial
      params:
        <<: *install-postgres-xenial-params
        USER_NAME: ubuntu

    - <<: *test-binary
      params:
        <<: *test-binary-params
        USER_NAME: ubuntu

- name: ec2-fedora-23
  serial: true
  plan:
  - get: bin-rc
    params:
      globs:
      - concourse_linux_amd64

  - <<: *launch-ec2-instance
    params:
      <<: *launch-ec2-instance-params
      USER_NAME: fedora
      IMAGE_ID: ami-518bfb3b

  - ensure:
      <<: *teardown-ec2-instance

    do:
    - <<: *install-postgres-fedora
      params:
        <<: *install-postgres-fedora-params
        OS: fedora
        USER_NAME: fedora

    - <<: *fedora-dependencies
      params:
        <<: *fedora-dependencies-params
        USER_NAME: fedora

    - <<: *test-binary
      params:
        <<: *test-binary-params
        USER_NAME: fedora

- name: ec2-amazon-linux
  serial: true
  plan:
  - get: bin-rc
    params:
      globs:
      - concourse_linux_amd64

  - <<: *launch-ec2-instance
    params:
      <<: *launch-ec2-instance-params
      USER_NAME: ec2-user
      IMAGE_ID: ami-f5f41398

  - ensure:
      <<: *teardown-ec2-instance

    do:

    - task: install-postgres
      params:
        USER_NAME: "ec2-user"

      config:
        platform: linux

        image_resource:
          type: docker-image
          source:
            repository: ruby
            tag: "2.1"

        inputs:
        - name: keys
        - name: instance

        run:
          path: bash
          args:
          - -c
          - |
            cat <<EOC > install_postgres
            set -ex

            until sudo yum update; do
              echo "waiting for yum lock"
              sleep 1
            done

            until sudo yum -y install postgresql; do
              echo "waiting for yum lock"
              sleep 1
            done

            sudo -Hiu postgres psql -U postgres postgres <<EOF
              CREATE USER $USER_NAME SUPERUSER PASSWORD '' ;
            EOF

            createdb atc
            EOC

            ip=$(cat instance/ip)

            scp -q -i keys/id_rsa -o StrictHostKeyChecking=no install_postgres $USER_NAME@${ip}:
            ssh -q -i keys/id_rsa -o StrictHostKeyChecking=no $USER_NAME@${ip} "chmod +x install_postgres && ./install_postgres"

    - <<: *test-binary
      params:
        <<: *test-binary-params
        USER_NAME: ec2-user
